# Overview

This page contains recommendations for the implementation of protection against path traversal attacks.

# General

<div align="left">
<img src="/.gitbook/assets/type-base-icon.svg">
</div>

- Do **not** allow a user to control data that is passed to the file system API.
- Generate random folder/file names using a UUID or random generator instead of relying on user-provided names, see the [Cryptography: Universal Unique Identifier (UUID)](/Web%20Application/Cryptography/Universal%20Unique%20Identifier%20(UUID)/README.md) and [Cryptography: Random Generators](/Web%20Application/Cryptography/Random%20Generators/README.md) pages.

- If data can be controlled by a user, implement comprehensive input validation for all data that is passed to the file system API, see the [Input Validation](/Web%20Application/Input%20Validation/README.md) page.

    - Use an allow list to validate user-provided data if possible.
    - Include only alphanumeric characters in an allow list.
    - If it is necessary to use special characters such as `.` or `/`, prevent the use of combinations represented as regular expressions below.

        ```
        \A\.\z
        \A\.\.\z
        \A\.\.[/\\]
        [/\\]\.\.\z
        [/\\]\.\.[/\\]
        \A/
        \A~
        \n
        \r
        ```

    - Do **not** rely solely on a block list validation, it can be bypassed in many cases.

- Make sure the canonicalized path starts with the expected base directory, see the [Implementing the canonical path validation](#implementing-the-canonical-path-validation) section.
- Methods used to construct file paths can have non-intuitive behaviour. Make sure the methods you use work as expected with data like this:

    ```
    .
    ..
    /
    ~/some/path
    /etc/passwd
    ../../../etc/passwd
    /../../../etc/passwd
    ../../../../../../../../../../../../etc/passwd
    ```

<details>
<summary>Clarification</summary>

For example, the `Pathname.join` method in Ruby, which joins pathnames, handles absolute names unintuitively.

```ruby
require 'pathname'

p = Pathname.new('tmp')

user_controlled_input = 'etc/passwd'
print(p.join('log', user_controlled_input, 'foo'))
# => tmp/log/etc/passwd/foo

user_controlled_input = '/etc/passwd'
print(p.join('log', user_controlled_input, ''))
# => /etc/passwd
```

As can be seen, if `user_controller_input` contains an absolute path, `Pathname.join` will ignore everything up to the argument with the absolute path. In other words, it will allow an attacker to craft an arbitrary path.
</details>

<div align="left">
<img src="/.gitbook/assets/type-advanced-icon.svg">
</div>

- Use a sandbox to obtain or save data.

# Implementing the canonical path validation

{% tabs %}
{% tab title="Go" %}

```go
package main

import (
	"fmt"
	"path"
	"strings"
)

func inTrastedBasePath(basePath string, userControlledPath string) bool {
	basePath = path.Join(basePath)
	fullPath := path.Join(basePath, userControlledPath)
	if !strings.HasPrefix(fullPath, basePath+"/") {
		return false
	}
	return true
}

func main() {
	basePath := "/tmp/path/to/base/folder"
	userControlledData := "nothing/dangerous.txt"
	fmt.Println(inTrastedBasePath(basePath, userControlledData))
    // => true

    userControlledData = "../../../path/traversal"
	fmt.Println(inTrastedBasePath(basePath, userControlledData))
    // => false
}
```
{% endtab %}

{% tab title="Java" %}

```java
import java.io.File;
import java.io.IOException;

public class CanonicalPathValidation {

    public static void main(String []args){
        String basePath = "/tmp/path/to/base/folder";
	    String userControlledData = "nothing/dangerous.txt";
        System.out.println(inTrustedBasePath(basePath, userControlledData));
        // => true

        String basePath = "/tmp/path/to/base/folder";
	    String userControlledData = "../../../path/traversal";
        System.out.println(inTrustedBasePath(basePath, userControlledData));
        // => false
    }

    private static boolean inTrustedBasePath(String basePath, String userControlledPath) {
        try {
            File file = new File(basePath, userControlledPath);
            if (!file.getCanonicalPath().startsWith(basePath)) {
                return false;
            }
            return true;
        } catch (IOException e) {
            return false;
        }
    }
}
```
{% endtab %}
{% endtabs %}

# References

- [GitLab Docs: Secure coding development guidelines](https://docs.gitlab.com/ee/development/secure_coding_guidelines.html#path-traversal-guidelines)
